package com.git.cs309.mmoserver.io;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.util.Calendar;

import javax.swing.AbstractListModel;
import javax.swing.ListModel;

import com.git.cs309.mmoserver.Config;
import com.git.cs309.mmoserver.gui.ServerGUI;
import com.git.cs309.mmoserver.util.CycleQueue;

public class Logger {
	private static final class LoggerListModel extends AbstractListModel<String> {

		/**
		 * 
		 */
		private static final long serialVersionUID = -3855629851629104651L;
		private static final LoggerListModel SINGLETON = new LoggerListModel();

		public static void fireContentsChanged() {
			SINGLETON.fireContentsChanged(SINGLETON, 0, outputList.size());
			ServerGUI.update();
		}

		public static LoggerListModel getSingleton() {
			return SINGLETON;
		}

		private LoggerListModel() {
			//To prevent external instantiation.
		}

		@Override
		public String getElementAt(int index) {
			return outputList.get(index);
		}

		@Override
		public int getSize() {
			return outputList.size();
		}

	}

	private static final class LoggerPrintStream extends PrintStream {
		private static LoggerPrintStream OUT; // Effectively final, just needs to not be final because of the try/catch in static.
		private static LoggerPrintStream ERR; // Same as above.
		private static final PrintStream defaultOutStream;
		private static final PrintStream defaultErrStream;
		private static volatile String pendingMessage = "";

		static {
			defaultOutStream = System.out;
			defaultErrStream = System.err;
			try {
				OUT = new LoggerPrintStream(false);
				ERR = new LoggerPrintStream(true);
			} catch (FileNotFoundException e) {
				e.printStackTrace();
				OUT = (LoggerPrintStream) System.out;
				ERR = (LoggerPrintStream) System.err;
			}
		}

		private static String ensureFileExists(boolean isErr) {
			File logPathFile = new File(
					Config.LOG_BASE_PATH + Calendar.getInstance().get(Calendar.YEAR) + "/" + getMonthAsString() + "/");
			logPathFile.mkdirs();
			File logFile = new File(Config.LOG_BASE_PATH + Calendar.getInstance().get(Calendar.YEAR) + "/"
					+ getMonthAsString() + "/" + Calendar.getInstance().get(Calendar.DAY_OF_MONTH) + (isErr ? " error " : "") + " logs - "
					+ getDayAsString() + ".log");
			try {
				logFile.createNewFile();
			} catch (IOException e) {
				e.printStackTrace();
			}
			return logFile.getAbsolutePath();
		}

		private static String getDayAsString() {
			switch (Calendar.getInstance().get(Calendar.DAY_OF_WEEK)) {
			case Calendar.SUNDAY:
				return "January";
			case Calendar.MONDAY:
				return "Monday";
			case Calendar.TUESDAY:
				return "Tuesday";
			case Calendar.WEDNESDAY:
				return "Wednesday";
			case Calendar.THURSDAY:
				return "Thursday";
			case Calendar.FRIDAY:
				return "Friday";
			case Calendar.SATURDAY:
				return "Saturday";
			}
			return "Null";
		}

		private static String getMonthAsString() {
			switch (Calendar.getInstance().get(Calendar.MONTH)) {
			case Calendar.JANUARY:
				return "January";
			case Calendar.FEBRUARY:
				return "February";
			case Calendar.MARCH:
				return "March";
			case Calendar.APRIL:
				return "April";
			case Calendar.MAY:
				return "May";
			case Calendar.JUNE:
				return "June";
			case Calendar.JULY:
				return "July";
			case Calendar.AUGUST:
				return "August";
			case Calendar.SEPTEMBER:
				return "September";
			case Calendar.OCTOBER:
				return "October";
			case Calendar.NOVEMBER:
				return "November";
			case Calendar.DECEMBER:
				return "December";
			}
			return "Null";
		}

		public static LoggerPrintStream getOut() {
			return OUT;
		}
		
		public static LoggerPrintStream getErr() {
			return ERR;
		}

		private LoggerPrintStream(boolean isErr) throws FileNotFoundException {
			super(new FileOutputStream(ensureFileExists(isErr), true));
			println();
		}

		@Override
		public void print(boolean b) {
			super.print(b);
			OUT.print(b);
			pendingMessage += b;
		}

		@Override
		public void print(char c) {
			super.print(c);
			OUT.print(c);
			pendingMessage += c;
		}

		@Override
		public void print(char[] s) {
			super.print(s);
			OUT.print(s);
			pendingMessage += String.valueOf(s);
		}

		@Override
		public void print(double d) {
			super.print(d);
			OUT.print(d);
			pendingMessage += d;
		}

		@Override
		public void print(float f) {
			super.print(f);
			OUT.print(f);
			pendingMessage += f;
		}

		@Override
		public void print(int i) {
			super.print(i);
			OUT.print(i);
			pendingMessage += i;
		}

		@Override
		public void print(long l) {
			super.print(l);
			OUT.print(l);
			pendingMessage += l;
		}

		@Override
		public void print(Object o) {
			super.print(o);
			OUT.print(o);
			pendingMessage += o;
		}

		@Override
		public void print(String message) {
			super.print(message);
			OUT.print(message);
			pendingMessage += message;
		}

		@Override
		public void println() {
			super.println();
			OUT.print('\n');
			outputList.add(pendingMessage);
			pendingMessage = "";
			LoggerListModel.fireContentsChanged();
		}

		@Override
		public void println(boolean b) {
			super.println(Logger.getTimeStamp() + " " + b);
			OUT.print('\n');
			outputList.add(pendingMessage);
			pendingMessage = "";
			LoggerListModel.fireContentsChanged();
		}

		@Override
		public void println(char c) {
			super.println(Logger.getTimeStamp() + " " + c);
			OUT.print('\n');
			outputList.add(pendingMessage);
			pendingMessage = "";
			LoggerListModel.fireContentsChanged();
		}

		@Override
		public void println(char[] s) {
			super.println(Logger.getTimeStamp() + " " + String.valueOf(s));
			OUT.print('\n');
			outputList.add(pendingMessage);
			pendingMessage = "";
			LoggerListModel.fireContentsChanged();
		}

		@Override
		public void println(double d) {
			super.println(Logger.getTimeStamp() + " " + d);
			OUT.print('\n');
			outputList.add(pendingMessage);
			pendingMessage = "";
			LoggerListModel.fireContentsChanged();
		}

		@Override
		public void println(float f) {
			super.println(Logger.getTimeStamp() + " " + f);
			OUT.print('\n');
			outputList.add(pendingMessage);
			pendingMessage = "";
			LoggerListModel.fireContentsChanged();
		}

		@Override
		public void println(int i) {
			super.println(Logger.getTimeStamp() + " " + i);
			OUT.print('\n');
			outputList.add(pendingMessage);
			pendingMessage = "";
			LoggerListModel.fireContentsChanged();
		}

		@Override
		public void println(long l) {
			super.println(Logger.getTimeStamp() + " " + l);
			OUT.print('\n');
			outputList.add(pendingMessage);
			pendingMessage = "";
			LoggerListModel.fireContentsChanged();
		}

		@Override
		public void println(Object o) {
			super.println(Logger.getTimeStamp() + " " + o);
			OUT.print('\n');
			outputList.add(pendingMessage);
			pendingMessage = "";
			LoggerListModel.fireContentsChanged();
		}

		@Override
		public void println(String message) {
			super.println(Logger.getTimeStamp() + " " + message);
			OUT.print('\n');
			outputList.add(pendingMessage);
			pendingMessage = "";
			LoggerListModel.fireContentsChanged();
		}
	}

	private static final CycleQueue<String> outputList = new CycleQueue<>(200, true);

	private static final Logger SINGLETON = new Logger();

	public static ListModel<String> getListModel() {
		return LoggerListModel.getSingleton();
	}

	public static PrintStream getPrintStream() {
		return LoggerPrintStream.getSingleton();
	}

	public static Logger getSingleton() {
		return SINGLETON;
	}

	public static String getTimeStamp() {
		int hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY);
		int minute = Calendar.getInstance().get(Calendar.MINUTE);
		int second = Calendar.getInstance().get(Calendar.SECOND);
		return "[" + (hour < 10 ? "0" : "") + hour + ":" + (minute < 10 ? "0" : "") + minute + ":"
				+ (second < 10 ? "0" : "") + second + "]";
	}

	private Logger() {

	}
}
